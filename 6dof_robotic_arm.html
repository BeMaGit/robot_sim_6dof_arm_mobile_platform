<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design A - User Tuned Camera</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 0 #fff;
            background: rgba(255, 255, 255, 0.6);
            padding: 10px;
        }

        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        #cam-label {
            position: absolute;
            bottom: 265px;
            right: 20px;
            color: white;
            background: #333;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: bold;
            border-radius: 3px 3px 0 0;
        }

        .key {
            display: inline-block;
            border: 1px solid #999;
            background: #eee;
            border-radius: 3px;
            padding: 0 5px;
            font-family: monospace;
            font-weight: bold;
            min-width: 15px;
            text-align: center;
        }

        .section-title {
            font-weight: bold;
            text-decoration: underline;
            margin-top: 5px;
            display: block;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        Design A: Manual Camera Position<br>
        <span style="font-size: 0.9em; color: #555;">Task: Pick up Blue Cube (Yellow=Ready) -> Move to Green
            Circle</span>
    </div>

    <div id="controls-help">
        <span class="section-title">Arm Controls (DE Layout)</span>
        <b>J2 (Shoulder):</b> <span class="key">Q</span> (Up) / <span class="key">A</span> (Down)<br>
        <b>J3 (Elbow):</b> <span class="key">W</span> / <span class="key">S</span><br>
        <b>J5 (Pitch):</b> <span class="key">E</span> / <span class="key">D</span><br>
        <b>Gripper:</b> <span class="key">R</span> (Open) / <span class="key">F</span> (Close)<br>
        <b>J1 (Waist):</b> <span class="key">Y</span> / <span class="key">X</span><br>
        <b>J6 (Roll):</b> <span class="key">C</span> / <span class="key">V</span><br>

        <span class="section-title">Mobile Base</span>
        <span class="key">‚¨ÜÔ∏è</span> <span class="key">‚¨áÔ∏è</span> <span class="key">‚¨ÖÔ∏è</span> <span class="key">‚û°Ô∏è</span>
        <span class="section-title">Mobile Base</span>
        <span class="key">‚¨ÜÔ∏è</span> <span class="key">‚¨áÔ∏è</span> <span class="key">‚¨ÖÔ∏è</span> <span class="key">‚û°Ô∏è</span>
    </div>

    <div id="json-control"
        style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; width: 300px; box-shadow: 0 0 10px rgba(0,0,0,0.1);">
        <strong>JSON Control (USB)</strong><br>
        <button id="btn-connect" style="margin-bottom: 5px; width: 100%;">üîå Connect to Robot</button>
        <div style="margin: 5px 0;">
            <label style="margin-right: 10px;"><input type="radio" name="target" value="usb" checked> Send to
                USB</label>
            <label><input type="radio" name="target" value="sim"> Apply to Sim</label>
        </div>
        <textarea id="json-input" rows="12" style="width: 100%; font-family: monospace; font-size: 11px;">{
  "servos": {
    "waist": 0,
    "shoulder": 180,
    "elbow": 180,
    "wristP": 90,
    "wristR": 90,
    "gripper": 50,
    "speed": 60
  },
  "motors": {
    "left": 100,
    "right": 100,
    "duration": 1000
  }
}</textarea>
        <button id="btn-send" style="width: 100%; margin-top: 5px;">üöÄ Send Command</button>
        <div id="serial-status" style="font-size: 10px; margin-top: 5px; color: #666;">Not Connected</div>
    </div>

    <div id="cam-label">J5 Wrist Camera</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Configuration ---
        const config = {
            jointColor: 0x333333,
            linkColor: 0xFFD700,
            metalColor: 0xAAAAAA,
            gripperColor: 0x222222,
            wheelColor: 0x111111,
            baseColor: 0x444444
        };

        // --- State ---
        // New Defaults matching Real Robot (Display Values)
        const defaults = { J1: 0, J2: 0, J3: 180, J5: 90, J6: 90, gripper: 50 };

        // Offsets: Visual = Display + Offset
        // J2: Display 180 -> Visual 0   => Offset -180 (Fixed: Up)
        // J3: Display 180 -> Visual 160 => Offset -20
        // J5: Display 90  -> Visual 10  => Offset -80
        // Gr: Display 50  -> Visual 0   => Offset -50
        const OFFSETS = { J2: -90, J3: -20, J5: -80, gripper: -50 };

        const params = {
            ...defaults, reset: function () {
                Object.assign(this, defaults);
                Object.assign(targetParams, defaults); // Sync target
                if (isGrasped) { scene.attach(interactiveCube); isGrasped = false; }
                cubeVelocityY = 0;
                interactiveCube.position.set(3, 0.25, 3);
                interactiveCube.rotation.set(0, 0, 0);
                interactiveCube.material.color.setHex(0x0044ff);
                mobileUnit.position.set(0, 0, 0);
                mobileUnit.rotation.set(0, 0, 0);
                updateJoints();
                gui.controllers.forEach(c => c.updateDisplay());
                syncFK();
            }
        };
        const targetParams = { ...defaults }; // Target for interpolation
        let simSpeed = 60; // Degrees per second (approx)
        const FPS = 60; // Assumed FPS for delta calculation

        const keys = {};
        const driveStats = { speed: 0.0, rotation: 0.0, maxSpeed: 0.1, maxRot: 0.04 };
        // Motor State
        const motorCmd = { active: false, speed: 0, rot: 0, endTime: 0 };
        const armSpeed = 1.0;
        const gripperSpeed = 2.0;
        let isGrasped = false;
        const GRASP_THRESHOLD = 0.8;
        let cubeVelocityY = 0;
        const GRAVITY = -0.015;
        const FLOOR_LEVEL = 0.25;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 20, 80);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(8, 8, 10);

        const cameraJ5 = new THREE.PerspectiveCamera(50, 320 / 240, 0.05, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Environment ---
        const gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0xcccccc);
        scene.add(gridHelper);
        const planeGeo = new THREE.PlaneGeometry(100, 100);
        const planeMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- Objects ---
        const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cubeMat = new THREE.MeshPhongMaterial({ color: 0x0044ff });
        const interactiveCube = new THREE.Mesh(cubeGeo, cubeMat);
        interactiveCube.position.set(3, 0.25, 3);
        interactiveCube.castShadow = true;
        interactiveCube.receiveShadow = true;
        scene.add(interactiveCube);

        const targetGeo = new THREE.RingGeometry(0.1, 1.5, 32);
        const targetMat = new THREE.MeshBasicMaterial({ color: 0x008800, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const targetCircle = new THREE.Mesh(targetGeo, targetMat);
        targetCircle.rotation.x = -Math.PI / 2;
        targetCircle.position.set(-4, 0.01, 2);
        scene.add(targetCircle);

        function createMesh(geometry, color) {
            const material = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // --- Robot ---
        const mobileUnit = new THREE.Group();
        scene.add(mobileUnit);
        const Z_OFFSET = -1.2;

        const chassis = createMesh(new THREE.BoxGeometry(2.5, 0.5, 3.5), config.baseColor);
        chassis.position.set(0, 0.5, Z_OFFSET); mobileUnit.add(chassis);
        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32).rotateZ(Math.PI / 2);
        const hubGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.42, 16).rotateZ(Math.PI / 2);
        const wFL = createMesh(wheelGeo, config.wheelColor); wFL.position.set(1.4, 0.5, -1.2 + Z_OFFSET); mobileUnit.add(wFL);
        const wFR = createMesh(wheelGeo, config.wheelColor); wFR.position.set(-1.4, 0.5, -1.2 + Z_OFFSET); mobileUnit.add(wFR);
        const wBL = createMesh(wheelGeo, config.wheelColor); wBL.position.set(1.4, 0.5, 1.2 + Z_OFFSET); mobileUnit.add(wBL); wBL.add(createMesh(hubGeo, 0xff0000));
        const wBR = createMesh(wheelGeo, config.wheelColor); wBR.position.set(-1.4, 0.5, 1.2 + Z_OFFSET); mobileUnit.add(wBR); wBR.add(createMesh(hubGeo, 0xff0000));

        const baseMesh = createMesh(new THREE.CylinderGeometry(0.8, 0.8, 0.2, 32), config.jointColor);
        baseMesh.position.set(0, 0.85, Z_OFFSET - 0.7); mobileUnit.add(baseMesh);
        const pivot1 = new THREE.Group(); pivot1.position.y = 0.1; baseMesh.add(pivot1);
        const pivot2 = new THREE.Group(); pivot2.position.y = 0.2; pivot1.add(pivot2);
        pivot2.add(createMesh(new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16).rotateX(Math.PI / 2), config.jointColor));

        // Link 2: Shoulder to Elbow (Physical: 20cm -> Sim: 2.0 units)
        // Box Height: 2.0. Center at 1.0 (to sit on pivot).
        const link2 = createMesh(new THREE.BoxGeometry(0.6, 2.0, 0.6), config.linkColor);
        link2.position.y = 1.0;
        pivot2.add(link2);

        const pivot3 = new THREE.Group();
        pivot3.position.y = 1.0; // At top of Link 2 (1.0 from center)
        link2.add(pivot3);

        // Link 3: Elbow to Wrist (Physical: 14cm -> Sim: 1.4 units)
        // Box Height: 1.4. Center at 0.7.
        const link3 = createMesh(new THREE.BoxGeometry(0.5, 1.4, 0.5), config.linkColor);
        link3.position.y = 0.7;
        pivot3.add(link3);

        const pivot5 = new THREE.Group();
        pivot5.position.y = 0.7; // At top of Link 3
        link3.add(pivot5);

        pivot5.add(createMesh(new THREE.CylinderGeometry(0.35, 0.35, 0.6, 16).rotateX(Math.PI / 2), config.jointColor));
        const link5 = createMesh(new THREE.BoxGeometry(0.4, 0.5, 0.4), config.metalColor); link5.position.y = 0.35; pivot5.add(link5);

        // ** J5 Camera: User Tuned Position **
        pivot5.add(cameraJ5);
        cameraJ5.position.set(-0.4, 0, 0);
        cameraJ5.rotation.x = Math.PI / 2;
        cameraJ5.rotation.z = - Math.PI / 2;

        // Visual indicator for the camera (Moved to match the camera position)
        const camVis = createMesh(new THREE.BoxGeometry(0.1, 0.1, 0.2), 0x000000);
        camVis.position.set(-0.4, 0, 0);
        // We rotate visual to match camera orientation roughly
        camVis.rotation.set(Math.PI / 2, 0, - Math.PI / 2);
        pivot5.add(camVis);

        const pivot6 = new THREE.Group(); pivot6.position.y = 0.5; link5.add(pivot6);
        const flange = createMesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), 0x333333); flange.position.y = 0.05; pivot6.add(flange);
        const gripperGroup = new THREE.Group(); gripperGroup.position.y = 0.1; flange.add(gripperGroup);
        const gripBase = createMesh(new THREE.BoxGeometry(0.8, 0.2, 0.3), config.gripperColor); gripBase.position.y = 0.1; gripperGroup.add(gripBase);
        const fingerL = createMesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), config.metalColor); fingerL.position.set(-0.2, 0.4, 0); gripBase.add(fingerL);
        const fingerR = createMesh(new THREE.BoxGeometry(0.1, 0.6, 0.3), config.metalColor); fingerR.position.set(0.2, 0.4, 0); gripBase.add(fingerR);
        const graspPoint = new THREE.Object3D(); graspPoint.position.set(0, 0.6, 0); gripBase.add(graspPoint);

        // --- Logic ---
        function updateJoints() {
            const rad = (deg) => deg * (Math.PI / 180);

            // Apply Offsets to convert Display -> Visual
            const visJ2 = params.J2 + OFFSETS.J2;
            const visJ3 = params.J3 + OFFSETS.J3;
            const visJ5 = params.J5 + OFFSETS.J5;
            const visGripper = params.gripper + OFFSETS.gripper;

            pivot1.rotation.y = rad(params.J1) - Math.PI / 2;
            pivot2.rotation.z = rad(visJ2);
            pivot3.rotation.z = rad(visJ3);
            pivot5.rotation.z = rad(visJ5);
            pivot6.rotation.y = rad(params.J6);

            // Visual Gripper 0 means gap=0.15. Range 0-100 logic.
            // If visGripper goes negative (Display < 50), it works.
            const gap = 0.15 + (visGripper / 100) * 0.25;
            // Clamp gap safely?
            // gap = Math.max(0.15, gap); // If desired

            fingerL.position.x = -gap; fingerR.position.x = gap;
        }

        function checkGraspLogic() {
            const graspWorldPos = new THREE.Vector3(); graspPoint.getWorldPosition(graspWorldPos);
            const cubeWorldPos = new THREE.Vector3(); interactiveCube.getWorldPosition(cubeWorldPos);
            const isCloseEnough = graspWorldPos.distanceTo(cubeWorldPos) < GRASP_THRESHOLD;
            if (!isGrasped) interactiveCube.material.color.setHex(isCloseEnough ? 0xFFD700 : 0x0044ff);

            // Params.gripper > 0 = Open. Close is < ...
            // Display: 50 is Closed(ish)? 
            // Original: > 50 open. < 10 close.
            // New Default: 50. visual 0.
            // Let's assume user keeps 0-100 logic relative to display?
            // If display > 60 open?
            // "gripper": 50 in JSON?

            // Maintain Logic relative to Display Value for simplicity
            // if (params.gripper < 40 ... ) 
            // Let's rely on standard UI interaction.

            if (params.gripper < 10 && !isGrasped && isCloseEnough) { gripperGroup.attach(interactiveCube); isGrasped = true; interactiveCube.material.color.setHex(0x00ff00); cubeVelocityY = 0; }
            if (params.gripper > 50 && isGrasped) { scene.attach(interactiveCube); isGrasped = false; interactiveCube.material.color.setHex(0x0044ff); interactiveCube.rotation.set(0, interactiveCube.rotation.y, 0); }
        }

        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        const gui = new GUI({ title: 'Design A Controls' });

        function maintainWrist() {
            if (params.wristLock) {
                // console.log("WristLock Active. Current Global:", currentState.globalPitch);
                // Goal: Keep Global Pitch constant
                // Current Body Angles: J2 (Shoulder), J3 (Elbow)
                // Use Visual Angles for Kinematics or Display?
                // Visual Angles correspond to physical geometry in Sim.

                const visJ2 = params.J2 + OFFSETS.J2;
                const visJ3 = params.J3 + OFFSETS.J3;

                const q1 = THREE.MathUtils.degToRad(visJ2);
                const q2 = THREE.MathUtils.degToRad(visJ3 - 180); // Original: J3-180. 
                // Wait, original logic: `rad(params.J3 - 180)`.
                // If original params.J3 was 160. rad(-20).
                // New visJ3 is 160. rad(-20). Correct matches.

                // qWrist = Global - (q1 + q2)
                const qWrist = currentState.globalPitch - (q1 + q2);
                let visJ5_deg = THREE.MathUtils.radToDeg(qWrist);

                // Convert Visual J5 -> Display J5
                // Display = Visual - Offset
                let displayJ5 = visJ5_deg - OFFSETS.J5;

                if (displayJ5 < 0) displayJ5 = 0; if (displayJ5 > 180) displayJ5 = 180;
                targetParams.J5 = params.J5 = displayJ5;

                // Update State for cleanliness
                const x = IK_L1 * Math.cos(q1) + IK_L2 * Math.cos(q1 + q2);
                const y = IK_L1 * Math.sin(q1) + IK_L2 * Math.sin(q1 + q2);
                currentState.x = x;
                currentState.y = y;
            }
            updateJoints();
        }

        const fJoints = gui.addFolder('Arm Angles');
        fJoints.add(params, 'J1', -90, 90).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();

        // Updated Ranges 0-180
        fJoints.add(params, 'J2', 0, 180).onChange(() => {
            Object.assign(targetParams, params);
            maintainWrist();
        }).listen();

        fJoints.add(params, 'J3', 0, 180).onChange(() => {
            Object.assign(targetParams, params);
            maintainWrist();
        }).listen();

        fJoints.add(params, 'J5', 0, 180).onChange(() => {
            Object.assign(targetParams, params);
            if (params.wristLock) {
                // If user Manually moves Wrist in Wrist Lock Mode, update the Global Pitch target
                const visJ2 = params.J2 + OFFSETS.J2;
                const visJ3 = params.J3 + OFFSETS.J3;
                const visJ5 = params.J5 + OFFSETS.J5;

                const q1 = THREE.MathUtils.degToRad(visJ2);
                const q2 = THREE.MathUtils.degToRad(visJ3 - 180);
                const qWrist = THREE.MathUtils.degToRad(visJ5); // Original used params.J5 directly as Angle?
                // Original: `pivot5.rotation.z = rad(params.J5)`. `rad(params.J5)` was qWrist.
                // In syncFK: `qWrist = degToRad(params.J5)`.
                // So yes, verify J5 matches visual angle logic.

                currentState.globalPitch = q1 + q2 + qWrist;
            }
            updateJoints();
        }).listen();

        fJoints.add(params, 'J6', 0, 180).onChange(() => { Object.assign(targetParams, params); updateJoints(); }).listen();
        const fTool = gui.addFolder('End Effector');
        fTool.add(params, 'gripper', 0, 100).name('Gripper Open').listen().onChange(() => { Object.assign(targetParams, params); updateJoints(); });

        // --- Wrist Lock Mode Setup ---
        params.wristLock = true;
        gui.add(params, 'wristLock').name('Lock Wrist (Level)').listen().onChange(() => {
            // Sync internal state logic if needed
            // For Sim, we reuse ikMode param name or rename it.
            // Let's rename for clarity. params.ikMode -> params.wristLock
            if (params.wristLock) {
                syncFK(); // Capture current state
                document.getElementById('info').innerHTML += "<br><span style='color:blue;'>Wrist Lock Active</span>";
            } else {
                document.getElementById('info').innerHTML = document.getElementById('info').innerHTML.replace("<br><span style='color:blue;'>Wrist Lock Active</span>", "");
            }
        });
        gui.add(params, 'reset').name('Reset Task');

        // IK State
        // Simulation Dimensions
        // Link 2 (Shoulder->Elbow): 2.0 units (Matches physical 20cm)
        // Link 3 (Elbow->Wrist): 1.4 units (Matches physical 14cm)
        const IK_L1 = 2.0;
        const IK_L2 = 1.4;

        let currentState = { x: 0, y: 0, globalPitch: 0 };

        function syncFK() {
            // Forward Kinematics to capture current X/Y and Global Pitch
            const visJ2 = params.J2 + OFFSETS.J2;
            const visJ3 = params.J3 + OFFSETS.J3;
            const visJ5 = params.J5 + OFFSETS.J5;

            const q1 = THREE.MathUtils.degToRad(visJ2); // Shoulder Visual
            const q2 = THREE.MathUtils.degToRad(visJ3 - 180); // Elbow (180 is straight)

            // Forward Kinematics
            // Base at (0,0) (Shoulder Pivot)
            currentState.x = IK_L1 * Math.cos(q1) + IK_L2 * Math.cos(q1 + q2);
            currentState.y = IK_L1 * Math.sin(q1) + IK_L2 * Math.sin(q1 + q2);

            // Wrist Relative to Horizon
            // Global = q1 + q2 + qWrist(J5)
            // Visual J5 = qWrist?
            const qWrist = THREE.MathUtils.degToRad(visJ5);
            currentState.globalPitch = q1 + q2 + qWrist;

            // console.log("FK Synced: ", currentState);
        }

        // Initial Sync
        syncFK();

        function updateIK(dX, dY) {
            // New Test Position
            const nextX = currentState.x + dX;
            const nextY = currentState.y + dY;

            // Reach Check
            const distSq = nextX * nextX + nextY * nextY;
            const maxReach = (IK_L1 + IK_L2) * 0.99;
            if (distSq > maxReach * maxReach) return;

            // Solve IK
            // Cosine Rule
            const c2 = (distSq - IK_L1 * IK_L1 - IK_L2 * IK_L2) / (2 * IK_L1 * IK_L2);
            if (c2 < -1.0 || c2 > 1.0) return;

            // Elbow Angle (q2)
            // Sim: J3=180 is Straight. 
            // Math: q2=0 is Straight.
            // Sim J3 = q2_deg + 180
            const q2 = -Math.acos(c2);

            // Shoulder Angle (q1)
            const k1 = IK_L1 + IK_L2 * Math.cos(q2);
            const k2 = IK_L2 * Math.sin(q2);
            const q1 = Math.atan2(nextY, nextX) - Math.atan2(k2, k1);

            // Convert to Sim Params (Visual)
            let visJ2_deg = THREE.MathUtils.radToDeg(q1);
            let visJ3_deg = THREE.MathUtils.radToDeg(q2) + 180;

            // Convert Visual -> Display
            let displayJ2 = visJ2_deg - OFFSETS.J2;
            let displayJ3 = visJ3_deg - OFFSETS.J3;

            // Constrain
            if (displayJ2 < 0) displayJ2 = 0; if (displayJ2 > 180) displayJ2 = 180;
            if (displayJ3 < 0) displayJ3 = 0; if (displayJ3 > 180) displayJ3 = 180;

            // Update State
            currentState.x = nextX;
            currentState.y = nextY;

            // Apply
            targetParams.J2 = params.J2 = displayJ2;
            targetParams.J3 = params.J3 = displayJ3;

            // Wrist Compensation
            // qWrist = Global - (q1 + q2)
            const qWrist = currentState.globalPitch - (q1 + q2);
            let visJ5_deg = THREE.MathUtils.radToDeg(qWrist);
            let displayJ5 = visJ5_deg - OFFSETS.J5;

            if (displayJ5 < 0) displayJ5 = 0; if (displayJ5 > 180) displayJ5 = 180;
            targetParams.J5 = params.J5 = displayJ5;
        }

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

        function animate() {
            requestAnimationFrame(animate);

            // --- Interpolation Logic ---
            const step = simSpeed / FPS;

            // Helper to move param towards target
            const moveTowards = (key, min, max) => {
                let curr = params[key];
                let targ = targetParams[key];
                if (Math.abs(curr - targ) > step) {
                    params[key] += (targ > curr) ? step : -step;
                } else {
                    params[key] = targ;
                }
                // Clamp acts as safe guard, though target should be clamped
                params[key] = clamp(params[key], min, max);
            };

            moveTowards('J1', 0, 180);
            moveTowards('J2', 0, 180);
            moveTowards('J3', 0, 180);
            moveTowards('J5', 0, 180);
            moveTowards('J6', 0, 180);
            moveTowards('gripper', 0, 100);

            // Manual Keys override target (and set it to keep sync)
            if (keys['q']) targetParams.J2 = params.J2 = clamp(params.J2 + armSpeed, -90, 90);
            if (keys['a']) targetParams.J2 = params.J2 = clamp(params.J2 - armSpeed, -90, 90);
            if (keys['w']) targetParams.J3 = params.J3 = clamp(params.J3 + armSpeed, 0, 180);
            if (keys['s']) targetParams.J3 = params.J3 = clamp(params.J3 - armSpeed, 0, 180);

            // Wrist J5 Keys: E/D
            if (keys['e']) {
                targetParams.J5 = params.J5 = clamp(params.J5 + armSpeed, 0, 180);
                if (params.wristLock) {
                    // Update Global Pitch to match new wrist angle
                    const q1 = THREE.MathUtils.degToRad(params.J2);
                    const q2 = THREE.MathUtils.degToRad(params.J3 - 90);
                    const qWrist = THREE.MathUtils.degToRad(params.J5);
                    currentState.globalPitch = q1 + q2 + qWrist;
                }
            }
            if (keys['d']) {
                targetParams.J5 = params.J5 = clamp(params.J5 - armSpeed, 0, 180);
                if (params.wristLock) {
                    // Update Global Pitch
                    const q1 = THREE.MathUtils.degToRad(params.J2);
                    const q2 = THREE.MathUtils.degToRad(params.J3 - 90);
                    const qWrist = THREE.MathUtils.degToRad(params.J5);
                    currentState.globalPitch = q1 + q2 + qWrist;
                }
            }

            if (keys['y'] || keys['z']) targetParams.J1 = params.J1 = clamp(params.J1 + armSpeed, -90, 90);
            if (keys['x']) targetParams.J1 = params.J1 = clamp(params.J1 - armSpeed, -90, 90);
            if (keys['c']) targetParams.J6 = params.J6 = clamp(params.J6 + armSpeed, -90, 90);
            if (keys['v']) targetParams.J6 = params.J6 = clamp(params.J6 - armSpeed, -90, 90);
            if (keys['r']) targetParams.gripper = params.gripper = clamp(params.gripper + gripperSpeed, 0, 100);
            if (keys['f']) targetParams.gripper = params.gripper = clamp(params.gripper - gripperSpeed, 0, 100);

            // Re-assert constraints if needed or Active Compensation
            if (params.wristLock && (keys['q'] || keys['a'] || keys['w'] || keys['s'])) {
                maintainWrist(); // Recalculate J5 based on new J2/J3
            }

            updateJoints();

            let speed = 0; let rot = 0;

            // Check Auto-Motor Command
            if (motorCmd.active) {
                if (Date.now() < motorCmd.endTime) {
                    speed = motorCmd.speed;
                    rot = motorCmd.rot;
                } else {
                    motorCmd.active = false;
                    console.log("Motor command finished");
                }
            }

            if (keys['arrowup']) speed -= driveStats.maxSpeed;
            if (keys['arrowdown']) speed += driveStats.maxSpeed;
            if (keys['arrowleft']) rot += driveStats.maxRot;
            if (keys['arrowright']) rot -= driveStats.maxRot;

            if (speed !== 0 || rot !== 0) {
                mobileUnit.rotation.y += rot;
                mobileUnit.position.addScaledVector(new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), mobileUnit.rotation.y), speed);
                const ws = speed * 2; wBL.rotation.x += ws; wBR.rotation.x += ws; wFL.rotation.x += ws; wFR.rotation.x += ws;
                const camT = mobileUnit.position.clone().add(new THREE.Vector3(0, 0, -Z_OFFSET).applyAxisAngle(new THREE.Vector3(0, 1, 0), mobileUnit.rotation.y));
                controls.target.copy(camT); controls.target.y += 2;
            }

            checkGraspLogic();

            if (!isGrasped) {
                cubeVelocityY += GRAVITY;
                interactiveCube.position.y += cubeVelocityY;
                if (interactiveCube.position.y <= FLOOR_LEVEL) {
                    interactiveCube.position.y = FLOOR_LEVEL;
                    cubeVelocityY = 0;
                }
            }

            if (!isGrasped && interactiveCube.position.y === FLOOR_LEVEL) {
                const d = new THREE.Vector2(interactiveCube.position.x, interactiveCube.position.z)
                    .distanceTo(new THREE.Vector2(targetCircle.position.x, targetCircle.position.z));
                targetMat.color.setHex(d < 1.0 ? 0x00ff00 : 0x008800);
                targetMat.opacity = d < 1.0 ? 0.8 : 0.5;
            }

            controls.update();

            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(true);
            renderer.clear();
            renderer.render(scene, camera);

            const pipWidth = 320;
            const pipHeight = 240;
            const pipLeft = window.innerWidth - pipWidth - 20;
            const pipBottom = 20;
            renderer.setViewport(pipLeft, pipBottom, pipWidth, pipHeight);
            renderer.setScissor(pipLeft, pipBottom, pipWidth, pipHeight);
            renderer.setScissorTest(true);
            renderer.render(scene, cameraJ5);
        }

        updateJoints();
        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // --- Web Serial Logic ---
        let port;
        let writer;
        const btnConnect = document.getElementById('btn-connect');
        const btnSend = document.getElementById('btn-send');
        const txtInput = document.getElementById('json-input');
        const lblStatus = document.getElementById('serial-status');

        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                // Check if the port is already open (writable)
                if (!port.writable) {
                    await port.open({ baudRate: 115200 }); // Match Arduino baudrate
                }

                // Setup writer if it doesn't exist
                if (!writer) {
                    const textEncoder = new TextEncoderStream();
                    const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
                    writer = textEncoder.writable.getWriter();
                }

                lblStatus.textContent = "Connected!";
                lblStatus.style.color = "green";
                btnConnect.disabled = true;
            } catch (err) {
                console.error(err);
                // Attempt recovery if port is somehow writable but writer failed
                if (port && port.writable && !writer) {
                    try {
                        const textEncoder = new TextEncoderStream();
                        const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
                        writer = textEncoder.writable.getWriter();
                        lblStatus.textContent = "Connected! (Recovered)";
                        lblStatus.style.color = "green";
                        btnConnect.disabled = true;
                        return;
                    } catch (e) { console.error("Recovery failed:", e); }
                }
                lblStatus.textContent = "Error: " + err.message;
            }
        }

        async function sendJSON() {
            const jsonStr = txtInput.value;
            let data;
            try {
                data = JSON.parse(jsonStr);
            } catch (err) {
                alert("Invalid JSON: " + err.message);
                return;
            }

            const target = document.querySelector('input[name="target"]:checked').value;

            if (target === 'usb') {
                if (!writer) {
                    alert("Please connect via USB first!");
                    return;
                }
                try {
                    await writer.write(jsonStr + "\n");
                    console.log("Sent to USB:", jsonStr);
                } catch (err) {
                    console.error("Write error:", err);
                    alert("Failed to send to USB");
                }
            } else {
                // Apply to Simulation (Update Targets for Animation)
                if (data.servos) {
                    if (data.servos.speed !== undefined) simSpeed = data.servos.speed;
                    if (data.servos.waist !== undefined) targetParams.J1 = data.servos.waist;
                    if (data.servos.shoulder !== undefined) targetParams.J2 = data.servos.shoulder;
                    if (data.servos.elbow !== undefined) targetParams.J3 = data.servos.elbow;
                    if (data.servos.wristP !== undefined) targetParams.J5 = data.servos.wristP;
                    if (data.servos.wristR !== undefined) targetParams.J6 = data.servos.wristR;
                    if (data.servos.gripper !== undefined) targetParams.gripper = data.servos.gripper;

                    // Do NOT call updateJoints() here, let animate() do it.
                    // We can log the target
                    console.log("New Target Set:", targetParams);
                    console.log("New Target Set:", targetParams);
                }

                if (data.motors) {
                    const left = data.motors.left || 0;
                    const right = data.motors.right || 0;
                    const duration = data.motors.duration || 0;

                    if (duration > 0) {
                        // Logic to map L/R (-255 to 255) to Speed/Rot
                        // Forward: L=100, R=100 -> Speed > 0, Rot = 0
                        // Turn Right: L=100, R=-100 -> Speed = 0, Rot < 0

                        // Simple averaging for speed (reversed polarity check?)
                        // If both positive, forward. 
                        const avg = (left + right) / 2;
                        const diff = (left - right); // Positive = Right turn? Check wiring.

                        // Map 255 to maxSpeed
                        const s = -(avg / 255) * driveStats.maxSpeed; // Negative is forward in Sim logic (see arrowup)
                        const r = -(diff / 255) * driveStats.maxRot; // Map turn

                        motorCmd.speed = s;
                        motorCmd.rot = r;
                        motorCmd.endTime = Date.now() + duration;
                        motorCmd.active = true;

                        console.log(`Motor Sim: Speed=${s.toFixed(3)}, Rot=${r.toFixed(3)} for ${duration}ms`);
                    }
                }

                console.log("Applied to Sim (Gradual):", jsonStr);
            }
        }

        btnConnect.addEventListener('click', connectSerial);
        btnSend.addEventListener('click', sendJSON);

    </script>
</body>

</html>